---
title: "Constraints on the variation of Chinese phrasal verbs"
output: 
  html_document:
  toc: true
  toc_depth: 2
  toc_float: true
date: "2026-01-12"
---
# Introduction

```{r loading packages, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE }

library(broom.mixed)
library(gt)
library(dplyr)
library(ggplot2)
library(car)         # to calculate VIFs
library(Hmisc)       # to calculate C values
library(party)       # for ctrees and CRF
#install.packages("lattice")
library(lattice)
library(lme4)        # for mixed-effects regression
library(MuMIn)       # for PSeudo R2 measures
library(effects)     # for partial effects plot
library(report)      # for description of various objects
library(parameters)  # to examine model effects
library(performance) # to assess and compare model performance
#install.packages("broom.mixed") #for plotting 
#install.packages("gt")
library(knitr)
#install.packages("gmodels")
library(gmodels)
```


```{r setup, echo=FALSE, eval=TRUE}
PV<-read.csv("merged_out.csv", sep=";", stringsAsFactors=TRUE)
PV_dis <- distinct(PV, Text, .keep_all = TRUE) # removing duplicates
PV_data<- PV_dis[rowSums(is.na(PV_dis) | PV_dis == "") < ncol(PV_dis), ] # removing NA/empty observations
summary(PV_data)
```

##data overview
```{r data_overview, fig.cap="Figure 1: data overview", echo=TRUE, eval=TRUE, message=FALSO, warning=FALSE}
library(base)
PV_data$Response<-as.factor(PV_data$Response)
PV_data$NP_Length<- as.numeric(PV_data$NP_Length)
#PV_data$Structural_priming<-as.factor(PV_data$Structural_priming)
#PV_data$NP_Givenness<-as.factor(PV_data$NP_Givenness)
PV_data$NP_Concreteness<- as.factor(PV_data$NP_Concreteness)
PV_data$NP_Definiteness<- as.factor(PV_data$NP_Definiteness)
PV_data$Time<- as.factor(PV_data$Time)
PV_data$Genre<- as.factor(PV_data$Genre)
PV_data$Imperative.conditional.<- as.factor(PV_data$Imperative.conditional.)
PV_data$le.<- as.factor(PV_data$le.)
PV_data$Numeric_Classifier<- as.factor(PV_data$Numeric_Classifier)

#the frequency of responses
response_counts <- table(PV_data$Response)
piechart<-pie(response_counts, 
    main = "Response Distribution", 
    col = rainbow(length(response_counts)), 
    labels = paste(names(response_counts), response_counts, sep=": ")) 
```

## converting responses to A, B and C types
```{r converting response to types, echo=FALSE, eval=FALSE}

```

## Variables
```{r variables, echo=TRUE, eval=TRUE}
library(knitr)

variables <- data.frame(
    Variable = c("Response", "NP_Length", "NP_Concreteness", "NP_Definiteness", "Time", "Genre", "Imperative.conditional.", "le.", "Numeric_Classifier"),
    Type = c("response variable", "numeric", "categorical", "categorical", "categorical", "categorical", "categorical", "categorical", "categorical"),
    Explanation = c("v_chu_n_lai vs. v_chulai_n vs. v_n_chulai", "Object NP length - character numbers ", "Concrete vs. Non-concrete", "Definite vs. Indefinite", "20-year intervals", "9 levels: Academic, Biography, Conversation, Fiction, Fiction_translation, Magazine, Newspaper, Online and TV/Movie", "Imperative vs. Conditional vs. No", "Absent vs. Present", "Absent vs. Present")
)

# Render as a table
kable(variables, caption = "Table 1: Data Annotation")
```

## Plotting NP_Length vs. Responses
```{r NP_Length Distribution, fig.cap="Figure 2: NP_Length vs. Responses', echo=TRUE, eval=TRUE, fig.width=6, fig.height=4}
PV_data$log_NP_Length <- log(PV_data$NP_Length) 

ggplot(PV_data, aes(x = Response, y = log_NP_Length)) +
  geom_boxplot(fill = "lightblue", color = "black") +
  stat_summary(fun = mean, geom = "point", shape = 18, color = "red", size = 3) +  # Mean (Red Diamond)
  stat_summary(fun = median, geom = "point", shape = 8, color = "blue", size = 3) +  # Median (Blue Star)
  labs(title = "Boxplot of log-transformed NP_Length vs. Response",
       x = "Response",
       y = "log_NP_Length") +
  theme_minimal()
```

#Results
##Conditional Random Forest(CRF)
```{r CRF model fitting, echo = TRUE, eval = TRUE, message=TRUE, warning=TRUE}
PV_data$Response <- droplevels(PV_data$Response)
set.seed(123) # esnures that we can reproduce results
forest = cforest(Response ~ Time + log_NP_Length +NP_Concreteness + NP_Definiteness + Genre + Imperative.conditional. + le. + Numeric_Classifier, data = PV_data)

#### calculate variable importance ranking, takes some time
forest.varimp = varimp(forest, conditional = FALSE) 

#### since Somers'D only works with binary responses,so we use ROC curve (see Hand&Till 2001) to replace C-value. The multiclass AUC is the average of all pairwise AUC.
##get predicted probabilities for all response classes
probs<-do.call(rbind, treeresponse(forest) )
##making sure responses are factors
y<-PV_data$Response
y<-factor(y)
##computing multiclass AUC using pROC
install.packages("pROC")
library(pROC) 
##before assessing AUC, we need to correct the name of porbs matrix to prevent mismatch. CRF tends to rename responses
colnames(probs) <- levels(y)
## now calculating pairwise ROC
levels_y <- levels(y) 
roc_list <- list() 
for (i in 1:(length(levels_y)-1)) { 
  for (j in (i+1):length(levels_y)) { 
    class_i <- levels_y[i] 
    class_j <- levels_y[j] 
    # subset data for the two classes 
    idx <- y %in% c(class_i, class_j) 
    # binary response for this pair 
    y_bin <- factor(y[idx] == class_i, levels = c(FALSE, TRUE)) 
    # probability of class_i 
    p_i <- probs[idx, class_i] 
    roc_list[[paste(class_i, class_j, sep = "_vs_")]] <- roc(y_bin, p_i) 
  } 
}

##plotting ROC objects
plot(roc_list[[1]]) 
plot(roc_list[[2]], add = TRUE, col = "blue") 
plot(roc_list[[3]], add = TRUE, col = "red")

```

## computing H&T multiclass AUC
```{r H&T multiclass AUC, echo=TRUE, eval=TRUE}
##computing pairwise AUCs
sapply(roc_list, auc)

##computing Hand & Till multiclass AUCs
pairwise_auc <- sapply(roc_list, auc) 
multiclass_auc <- mean(pairwise_auc) 
multiclass_auc
```

## plotting CRF

```{r CRF plotting, fig.cap="Figure 5: Factor importance ranking" ,echo = TRUE, eval = TRUE, fig.width=6, fig.height=4}
dotplot(sort(forest.varimp), xlab="Variable Importance", panel = function(x,y){
  panel.dotplot(x, y, col='darkblue', pch=16, cex=1.1)
  panel.abline(v=abs(min(forest.varimp)), col='red',
               lty='longdash', lwd=2)
}
) 
```

## Byesian Multinomial regression analysis

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
